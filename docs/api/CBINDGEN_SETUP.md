# cbindgen Setup Guide

**Purpose**: Automatically generate C header file from Rust FFI code

---

## What is cbindgen?

`cbindgen` is a tool that generates C/C++ header files from Rust source code. It reads your Rust FFI declarations and produces matching C headers automatically.

**Benefits**:
- No manual header maintenance
- Type safety (header always matches implementation)
- Automatic documentation from Rust doc comments
- Handles complex types correctly

---

## Installation

```bash
cargo install cbindgen
```

---

## Configuration File

Create `cbindgen.toml` in project root:

```toml
# cbindgen.toml

# Programming language for header (C or C++)
language = "C"

# Header guard
header = "/* Auto-generated by cbindgen - DO NOT EDIT MANUALLY */"
include_guard = "WORDLIST_GENERATOR_H"

# Output settings
autogen_warning = "/* Warning: This file is auto-generated. Edit src/ffi.rs instead. */"
tab_width = 4
line_length = 100

# Include system headers
sys_includes = ["stddef.h", "stdint.h", "cuda.h"]

# Namespace (for C++)
namespace = "wordlist_generator"

# Documentation style
documentation = true
documentation_style = "doxy"

# Function prefix (optional)
# prefix = "wg_"

# Struct/enum settings
[struct]
derive_eq = false
derive_neq = false

[enum]
rename_variants = "ScreamingSnakeCase"

# Export configuration
[export]
# Only export items in src/ffi.rs
include = ["WordlistGenerator", "BatchDevice", "OutputFormat"]
# Prefix for types
prefix = "wg_"

# Rename rules
[export.rename]
"WordlistGenerator" = "WordlistGenerator"
"BatchDevice" = "batch_device_t"
"OutputFormat" = "output_format_t"

# Function export
[export.body]
# Export all #[no_mangle] pub extern "C" functions

# Type aliases
[parse]
parse_deps = false
include = ["src/ffi.rs"]

# Layout tests (generates assertions about struct layout)
[layout]
packed = "Wordlist Generator"
aligned = false
```

---

## Directory Structure

```
gpu-scatter-gather/
├── cbindgen.toml          # cbindgen configuration
├── Cargo.toml
├── build.rs               # Build script (runs cbindgen)
├── src/
│   ├── lib.rs
│   └── ffi.rs             # FFI declarations
├── include/
│   └── wordlist_generator.h  # Generated header (auto)
└── target/
    └── release/
        ├── libwordlist_generator.so
        └── libwordlist_generator.a
```

---

## Build Script

Create/update `build.rs`:

```rust
// build.rs

use std::env;
use std::path::PathBuf;

fn main() {
    // Get output directory
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    // Run cbindgen
    let config = cbindgen::Config::from_file("cbindgen.toml")
        .expect("Unable to find cbindgen.toml");

    cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_config(config)
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file("include/wordlist_generator.h");

    println!("cargo:rerun-if-changed=src/ffi.rs");
    println!("cargo:rerun-if-changed=cbindgen.toml");
}
```

Add to `Cargo.toml`:

```toml
[build-dependencies]
cbindgen = "0.26"
```

---

## Example Input (Rust FFI)

```rust
// src/ffi.rs

use std::os::raw::c_char;

/// Opaque handle to wordlist generator
#[repr(C)]
pub struct WordlistGenerator {
    _private: [u8; 0],
}

/// Output format modes
#[repr(C)]
#[derive(Copy, Clone)]
pub enum OutputFormat {
    /// Each word terminated by newline
    Newlines = 0,
    /// Fixed-width, null-padded
    FixedWidth = 1,
    /// No separators, packed
    Packed = 2,
}

/// Device batch result
#[repr(C)]
pub struct BatchDevice {
    /// Device pointer to candidates
    pub data: u64,
    /// Number of candidates
    pub count: u64,
    /// Length of each word
    pub word_length: usize,
    /// Bytes between word starts
    pub stride: usize,
}

/// Create a new wordlist generator
///
/// # Arguments
/// * `ctx` - CUDA context (NULL to create new)
/// * `device_id` - CUDA device ID (0 for first GPU)
///
/// # Returns
/// Generator handle, or NULL on error
#[no_mangle]
pub extern "C" fn wg_create(
    ctx: *mut std::ffi::c_void,
    device_id: i32,
) -> *mut WordlistGenerator {
    // ... implementation ...
    std::ptr::null_mut()
}

/// Destroy generator and free resources
#[no_mangle]
pub extern "C" fn wg_destroy(gen: *mut WordlistGenerator) {
    // ... implementation ...
}

/// Set charset
#[no_mangle]
pub extern "C" fn wg_set_charset(
    gen: *mut WordlistGenerator,
    charset_id: i32,
    chars: *const c_char,
    len: usize,
) -> i32 {
    // ... implementation ...
    0
}
```

---

## Generated Output (C Header)

```c
/* Auto-generated by cbindgen - DO NOT EDIT MANUALLY */
/* Warning: This file is auto-generated. Edit src/ffi.rs instead. */

#ifndef WORDLIST_GENERATOR_H
#define WORDLIST_GENERATOR_H

#include <stddef.h>
#include <stdint.h>
#include <cuda.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * Opaque handle to wordlist generator
 */
typedef struct WordlistGenerator WordlistGenerator;

/**
 * Output format modes
 */
typedef enum {
    /**
     * Each word terminated by newline
     */
    NEWLINES = 0,
    /**
     * Fixed-width, null-padded
     */
    FIXED_WIDTH = 1,
    /**
     * No separators, packed
     */
    PACKED = 2,
} OutputFormat;

/**
 * Device batch result
 */
typedef struct {
    /**
     * Device pointer to candidates
     */
    uint64_t data;
    /**
     * Number of candidates
     */
    uint64_t count;
    /**
     * Length of each word
     */
    size_t word_length;
    /**
     * Bytes between word starts
     */
    size_t stride;
} BatchDevice;

/**
 * Create a new wordlist generator
 *
 * # Arguments
 * * `ctx` - CUDA context (NULL to create new)
 * * `device_id` - CUDA device ID (0 for first GPU)
 *
 * # Returns
 * Generator handle, or NULL on error
 */
WordlistGenerator *wg_create(void *ctx, int32_t device_id);

/**
 * Destroy generator and free resources
 */
void wg_destroy(WordlistGenerator *gen);

/**
 * Set charset
 */
int32_t wg_set_charset(WordlistGenerator *gen,
                       int32_t charset_id,
                       const char *chars,
                       size_t len);

#ifdef __cplusplus
}
#endif

#endif /* WORDLIST_GENERATOR_H */
```

---

## Build Process

```bash
# Build library (runs cbindgen automatically)
cargo build --release

# Header is generated at: include/wordlist_generator.h
# Library is built at: target/release/libwordlist_generator.so
```

---

## Manual Header Generation

```bash
# Generate header without building
cbindgen --config cbindgen.toml --crate gpu-scatter-gather --output include/wordlist_generator.h

# Verify header
cat include/wordlist_generator.h
```

---

## Common Issues

### Issue 1: cbindgen not finding types

**Solution**: Add to `cbindgen.toml`:
```toml
[parse]
parse_deps = true
include = ["src"]
extra_bindings = ["src/ffi.rs"]
```

### Issue 2: Missing CUDA types

**Solution**: Include cuda.h in sys_includes:
```toml
sys_includes = ["cuda.h"]
```

### Issue 3: Wrong struct layout

**Solution**: Use `#[repr(C)]` on all FFI structs in Rust

---

## Validation

### Test Header Compiles

```c
// test_header.c
#include "include/wordlist_generator.h"

int main() {
    WordlistGenerator* gen = wg_create(NULL, 0);
    wg_destroy(gen);
    return 0;
}
```

```bash
gcc -c test_header.c -I. -I/usr/local/cuda/include
```

### Test Struct Sizes Match

```c
// test_layout.c
#include "include/wordlist_generator.h"
#include <assert.h>
#include <stdio.h>

int main() {
    printf("sizeof(BatchDevice) = %zu\n", sizeof(BatchDevice));
    // Should match Rust: 8+8+8+8 = 32 bytes
    assert(sizeof(BatchDevice) == 32);
    return 0;
}
```

---

**End of cbindgen Setup Guide**
